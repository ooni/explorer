import { useMemo, useState } from 'react'
import { useIntl } from 'react-intl'

import Filters from './Filters'
import GridChart, { prepareDataForGridChart } from './GridChart'
import { useMATContext } from './MATContext'
import { APIButtons } from '../../APIButtons'

const DEFAULT_ROW_TEMPLATE = {
  anomaly_count: 0,
  confirmed_count: 0,
  failure_count: 0,
  measurement_count: 0,
  count: 0,
}

// create a new row with default values
const createRowTemplate = (key, rowLabel, axisY) => ({
  [axisY]: key,
  rowLabel,
  ...DEFAULT_ROW_TEMPLATE,
})

// aggregate counts for a single row
const aggregateRowCounts = (rowData, countKeys) => {
  const aggregatedRow = countKeys.reduce(
    (acc, countKey) => ({ ...acc, [countKey]: 0 }),
    {},
  )

  for (const dataPoint of rowData) {
    for (const countKey of countKeys) {
      aggregatedRow[countKey] += dataPoint[countKey] || 0
    }
  }

  return aggregatedRow
}

const getBlockedMax = (rowData) => {
  return rowData.reduce(
    (acc, dataPoint) => {
      acc.blocked_max = Math.max(acc.blocked_max, dataPoint.blocked_max)
      return acc
    },
    { blocked_max: 0 },
  )
}

const processRow = (key, rowData, rowLabels, query, countKeys) => {
  const rowLabel = rowLabels[key]
  const baseRow = createRowTemplate(key, rowLabel, query.axis_y)
  const aggregatedCounts =
    query.data === 'analysis'
      ? getBlockedMax(rowData)
      : aggregateRowCounts(rowData, countKeys)
  return {
    ...baseRow,
    ...aggregatedCounts,
  }
}

const prepareDataforTable = (
  data,
  query,
  locale,
  includedItems,
  selectedItems,
  countKeys,
) => {
  const [reshapedData, rows, rowLabels] = prepareDataForGridChart(
    data,
    query,
    locale,
    includedItems,
    selectedItems,
  )

  // Process each row and build the table
  const table = Array.from(reshapedData, ([key, rowData]) => {
    return processRow(key, rowData, rowLabels, query, countKeys)
  })
  return [reshapedData, table, rows, rowLabels]
}

// This same reference is passed to GridChart when there are no rows to filter out
// Maybe this can also be `[]`
const noRowsSelected = null

const TableView = ({ data, query, showFilters = true, apiEndpoint }) => {
  const intl = useIntl()
  const { state } = useMATContext()

  // The incoming data is reshaped to generate:
  // - reshapedData: holds the full set that will be used by GridChart
  //   to then filter out rows based on `selectedRows` generated by the table
  // - tableData: this has aggregated counts and labels for each row to be
  //   displayed in GridChart. It allows to easily filter and sort aggregate data
  // - indexes -
  const [reshapedData, tableData, rowKeys, rowLabels] = useMemo(() => {
    try {
      return prepareDataforTable(
        data,
        query,
        intl.locale,
        state.included,
        state.selected,
        state.countKeys,
      )
    } catch (e) {
      return [null, [], [], {}]
    }
  }, [
    query,
    data,
    intl.locale,
    state.included,
    state.selected,
    state.countKeys,
  ])

  const [dataForCharts, setDataForCharts] = useState(noRowsSelected)

  return (
    <div className="flex flex-col">
      <GridChart
        data={reshapedData}
        selectedRows={dataForCharts}
        rowKeys={rowKeys}
        rowLabels={rowLabels}
      />
      <APIButtons apiEndpoint={apiEndpoint} />
      {showFilters && (
        <div className="mt-8">
          <Filters
            query={query}
            data={tableData}
            setDataForCharts={setDataForCharts}
          />
        </div>
      )}
    </div>
  )
}

export default TableView
