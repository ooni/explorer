import { useMemo, useState } from 'react'
import { useIntl } from 'react-intl'

import Filters from './Filters'
import GridChart, { prepareDataForGridChart } from './GridChart'
import { useFailureTypes } from './FailureTypesContext'

const COUNT_KEYS_CONFIG = {
  // outcome: ['outcome_blocked', 'outcome_down', 'outcome_ok'],
  // detailed: ['dns_isp_blocked', 'dns_isp_down', 'dns_isp_ok'],
  default: [
    'anomaly_count',
    'confirmed_count',
    'failure_count',
    'measurement_count',
  ],
}

const DEFAULT_ROW_TEMPLATE = {
  anomaly_count: 0,
  confirmed_count: 0,
  failure_count: 0,
  measurement_count: 0,
  dns_isp: 0,
  dns_other: 0,
  tls: 0,
  tcp: 0,
  count: 0,
  loni: {
    dns_isp: { blocked: 0, down: 0, ok: 0 },
    dns_other: { blocked: 0, down: 0, ok: 0 },
    tls: { blocked: 0, down: 0, ok: 0 },
    tcp: { blocked: 0, down: 0, ok: 0 },
  },
}

const getCountKeys = (query, selectedItems) => {
  // if (query.loni === 'outcome') return COUNT_KEYS_CONFIG.outcome
  // if (query.loni === 'detailed') return COUNT_KEYS_CONFIG.detailed
  if (query.loni === 'outcome') return ['blocked_max']
  if (query.loni === 'observations') return selectedItems
  return COUNT_KEYS_CONFIG.default
}

// create a new row with default values
const createRowTemplate = (key, rowLabel, axisY) => ({
  [axisY]: key,
  rowLabel,
  ...DEFAULT_ROW_TEMPLATE,
})

// aggregate counts for a single row
const aggregateRowCounts = (rowData, countKeys) => {
  const aggregatedRow = countKeys.reduce(
    (acc, countKey) => ({ ...acc, [countKey]: 0 }),
    {},
  )

  for (const dataPoint of rowData) {
    for (const countKey of countKeys) {
      aggregatedRow[countKey] += dataPoint[countKey] || 0
    }
  }

  return aggregatedRow
}

const getBlockedMax = (rowData) => {
  return rowData.reduce(
    (acc, dataPoint) => {
      acc.blocked_max = Math.max(acc.blocked_max, dataPoint.blocked_max)
      return acc
    },
    { blocked_max: 0 },
  )
}

const processRow = (key, rowData, rowLabels, query, countKeys) => {
  const rowLabel = rowLabels[key]
  const baseRow = createRowTemplate(key, rowLabel, query.axis_y)
  const aggregatedCounts =
    query.loni === 'outcome'
      ? getBlockedMax(rowData)
      : aggregateRowCounts(rowData, countKeys)
  return {
    ...baseRow,
    ...aggregatedCounts,
  }
}

const prepareDataforTable = (
  data,
  query,
  locale,
  includedItems,
  selectedItems,
) => {
  const [reshapedData, rows, rowLabels] = prepareDataForGridChart(
    data,
    query,
    locale,
    includedItems,
    selectedItems,
  )

  // Determine which count keys to use
  const countKeys = getCountKeys(query, selectedItems)

  // Process each row and build the table
  const table = Array.from(reshapedData, ([key, rowData]) =>
    processRow(key, rowData, rowLabels, query, countKeys),
  )

  return [reshapedData, table, rows, rowLabels]
}

// This same reference is passed to GridChart when there are no rows to filter out
// Maybe this can also be `[]`
const noRowsSelected = null

const TableView = ({ data, query, showFilters = true }) => {
  const intl = useIntl()
  const { state } = useFailureTypes()

  // The incoming data is reshaped to generate:
  // - reshapedData: holds the full set that will be used by GridChart
  //   to then filter out rows based on `selectedRows` generated by the table
  // - tableData: this has aggregated counts and labels for each row to be
  //   displayed in GridChart. It allows to easily filter and sort aggregate data
  // - indexes -
  const [reshapedData, tableData, rowKeys, rowLabels] = useMemo(() => {
    try {
      return prepareDataforTable(
        data,
        query,
        intl.locale,
        state.included,
        state.selected,
      )
    } catch (e) {
      return [null, [], [], {}]
    }
  }, [query, data, intl.locale, state.included, state.selected])

  const [dataForCharts, setDataForCharts] = useState(noRowsSelected)

  return (
    <div className="flex flex-col">
      <GridChart
        data={reshapedData}
        selectedRows={dataForCharts}
        rowKeys={rowKeys}
        rowLabels={rowLabels}
      />
      {showFilters && (
        <div className="mt-8">
          <Filters
            query={query}
            data={tableData}
            setDataForCharts={setDataForCharts}
          />
        </div>
      )}
    </div>
  )
}

export default TableView
